    /**
     * Fela Renderer
     */
    export class FelaRenderer extends React.ComponentType<React.ConsumerProps<IRenderer>> {}

    export const RendererContext: React.Context<IRenderer>

    interface RenderProps<T> {
      className: string,
      theme: T,
      as: keyof React.ReactHTML,
    }

    export type StyleProps<T, P = {}> = { theme: T } & {
      [K in keyof P]?: P[K]
    }

    export type StyleFunction<T, P = {}> = (styleProps: StyleProps<T, P>) => IStyle

    export type FelaStyle<T, P = {}> = IStyle | StyleFunction<T, P> | Array<StyleFunction<T, P> | IStyle>

    export interface WithStyle<T, P> {
      style: FelaStyle<T, P>
    }

    interface FelaComponentProps<T, P = {}> {
      children?: ((renderProps: RenderProps<T>) => React.ReactNode) | React.ReactNode,
      customClass?: string,
      style: FelaStyle<T, P>,
      as?: keyof React.ReactHTML,
    }

    // NOT WORKING WITH strictFunctionTypes=true
    //
    // see stacktrace
    // The expected type comes from property 'style' which is declared here on type
    // 'IntrinsicAttributes & IntrinsicClassAttributes<FelaComponent<{}, { children: {} | null | undefined;
    // style: IStyle | StyleFunction<T, {}> | (IStyle | StyleFunction<T, {}>)[]; spacing: ReactText; }>> & Readonly<...>
    // & Readonly<...>'
    export class FelaComponent<T, P = {}> extends React.Component<FelaComponentProps<T, P> & P> {
    }

    export type CssFunctionStyle<T, P, S> = S | StyleFunction<T, P>
    export type CssFunction<T, P, S extends IStyle> = (...style: CssFunctionStyle<T, P, S>) => string

    // NOT WORKING WITH strictFunctionTypes=true
    // The properties passed to css have to be either of Type IStyle or StyleFunction.
    // However, this alternative type is not evaluated correctly because the
    // Typescript compiler translates it to any.
    export interface FelaHookProps<T, P> {
      css: CssFunction<T, P>,
      theme: T,
      renderer: IRenderer,
    }

    export function useFela<T = {}, P = {}>(props?: P): FelaHookProps<T, P>
